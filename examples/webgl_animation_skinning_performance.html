<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - animation - skinning - performance</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			a {
				color: #f00;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			 - Performance Test Scene of GPU Implementations for Skeletal Animations<br/>
			(Soldier model from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">mixamo.com</a>,
			mask model made by Iker J. de los Mozos, <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC Attribution</a>)<br/>
			Note: crossfades are possible with blend weights being set to (1,0,0), (0,1,0) or (0,0,1)
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let scene, renderer, camera, stats;
			let clock;

			const crossFadeControls = [];
			const skeletons = [];
			const mixers = [];
			const models = [];
			let head;
			let envMap;

			let idleWeight, walkWeight, runWeight;
			const idleActions = [];
			const walkActions = [];
			const runActions = [];
			const actions = [];
			let settings;

			let singleStepMode = false;
			let sizeOfNextStep = 0;

			let soldiersLoaded = false;
			let headLoaded = false;
			let envMapLoaded = false;

			init();

			function init() {

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 1, 2, - 3 );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.position.set( - 3, 10, - 10 );
				scene.add( dirLight );

				// ground

				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const loader = new GLTFLoader( undefined, {
					useBoneIndexWeightsTexture: THREE.BoneIndexWeightsTextureAlways
				} );

				loader.load( 'models/gltf/Soldier.glb', function ( gltf ) {

					const model = gltf.scene;
					const animations = gltf.animations;

					revertVertexSkinningBuffers( model );

					for ( let row = 0; row < 20; ++ row ) {

						for ( let col = 0; col < 20; ++ col ) {

							const modelClone = SkeletonUtils.clone( model );
							modelClone.position.set( - row + 3, 0, col );

							//

							const skeleton = new THREE.SkeletonHelper( modelClone );
							skeleton.visible = false;
							skeletons.push( skeleton );
							scene.add( skeleton );

							//

							const mixer = new THREE.AnimationMixer( modelClone );
							mixers.push( mixer );

							const idle = mixer.clipAction( animations[ 0 ] );
							const walk = mixer.clipAction( animations[ 3 ] );
							const run = mixer.clipAction( animations[ 1 ] );
							idleActions.push( idle );
							walkActions.push( walk );
							runActions.push( run );

							actions.push( idle, walk, run );

							models.push( modelClone );
							scene.add( modelClone );

						}

					}

					soldiersLoaded = true;
					finishInitialization();

				} );

				// Show a model that has artifacts without weight texture skinning
				// so that we're confident it's really on
				loader.load( 'models/gltf/HeadWithMax16Joints.glb', function ( gltf ) {

					head = gltf.scene;

					scene.add( head );
					models.push( head );

					head.position.set( 0, 1, - 1 );
					head.rotation.y = - Math.PI;

					revertVertexSkinningBuffers( head );

					const mixer = new THREE.AnimationMixer( head );
					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();
					actions.push( action );
					mixers.push( mixer );

					headLoaded = true;
					finishInitialization();

				} );

				new THREE.TextureLoader().load(
					'textures/2294472375_24a3b8ef46_o.jpg',
					texture => {

						envMap = texture;
						envMap.mapping = THREE.EquirectangularReflectionMapping;
						envMap.colorSpace = THREE.SRGBColorSpace;

						envMapLoaded = true;
						finishInitialization();

					} );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

			}

			function finishInitialization() {

				if ( ! soldiersLoaded || ! headLoaded || ! envMapLoaded ) return;

				head.traverse( object => {

					if ( object.material && object.material.isMeshPhysicalMaterial ) {

						// MeshPhysicalMaterial looks better with an environment map
						object.material.envMap = envMap;

					}

				} );

				// The scene must be complete before modifying or starting rendering.
				// Otherwise, there's access to incomplete state and automated
				// screenshots are non-deterministic.

				createPanel();
				activateAllActions();
				animate();

			}

			function createPanel() {

				const panel = new GUI( { width: 310 } );

				const folder0 = panel.addFolder( 'Skinning' );
				const folder1 = panel.addFolder( 'Visibility' );
				const folder2 = panel.addFolder( 'Activation/Deactivation' );
				const folder3 = panel.addFolder( 'Pausing/Stepping' );
				const folder4 = panel.addFolder( 'Crossfading' );
				const folder5 = panel.addFolder( 'Blend Weights' );
				const folder6 = panel.addFolder( 'General Speed' );

				settings = {
					'use skin weights texture': true,
					'show model': true,
					'show skeleton': false,
					'deactivate all': deactivateAllActions,
					'activate all': activateAllActions,
					'pause/continue': pauseContinue,
					'make single step': toSingleStepMode,
					'modify step size': 0.05,
					'from walk to idle': function () {

						prepareCrossFade( walkActions, idleActions, 1.0 );

					},
					'from idle to walk': function () {

						prepareCrossFade( idleActions, walkActions, 0.5 );

					},
					'from walk to run': function () {

						prepareCrossFade( walkActions, runActions, 2.5 );

					},
					'from run to walk': function () {

						prepareCrossFade( runActions, walkActions, 5.0 );

					},
					'use default duration': true,
					'set custom duration': 3.5,
					'modify idle weight': 0.0,
					'modify walk weight': 1.0,
					'modify run weight': 0.0,
					'modify time scale': 1.0
				};

				folder0.add( settings, 'use skin weights texture' ).onChange( changeSkinningMethod );
				folder1.add( settings, 'show model' ).onChange( showModel );
				folder1.add( settings, 'show skeleton' ).onChange( showSkeleton );
				folder2.add( settings, 'deactivate all' );
				folder2.add( settings, 'activate all' );
				folder3.add( settings, 'pause/continue' );
				folder3.add( settings, 'make single step' );
				folder3.add( settings, 'modify step size', 0.01, 0.1, 0.001 );
				crossFadeControls.push( folder4.add( settings, 'from walk to idle' ) );
				crossFadeControls.push( folder4.add( settings, 'from idle to walk' ) );
				crossFadeControls.push( folder4.add( settings, 'from walk to run' ) );
				crossFadeControls.push( folder4.add( settings, 'from run to walk' ) );
				folder4.add( settings, 'use default duration' );
				folder4.add( settings, 'set custom duration', 0, 10, 0.01 );
				folder5.add( settings, 'modify idle weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {

					setWeight( idleActions, weight );

				} );
				folder5.add( settings, 'modify walk weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {

					setWeight( walkActions, weight );

				} );
				folder5.add( settings, 'modify run weight', 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {

					setWeight( runActions, weight );

				} );
				folder6.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );

				folder1.open();
				folder2.open();
				folder3.open();
				folder4.open();
				folder5.open();
				folder6.open();

			}

			function revertVertexSkinningBuffers( model ) {

				model.traverse( ( object ) => {

					if ( ! object.isSkinnedMesh ) return;

					// Revert the skin weights vertex buffer to <= 4 weights behavior
					// so that we can quickly change between skinning approaches
					// (vertex buffer vs texture).
					object.useBoneIndexWeightsTexture = THREE.BoneIndexWeightsTextureNever;
					object.normalizeSkinWeights();
					object.useBoneIndexWeightsTexture = THREE.BoneIndexWeightsTextureAlways;

				} );

			}

			function changeSkinningMethod( useWeightsTexture ) {

				for ( const model of models ) {

					model.traverse( ( object ) => {
			
						if ( ! object.isSkinnedMesh ) return;

						object.useBoneIndexWeightsTexture =
							useWeightsTexture ?
								THREE.BoneIndexWeightsTextureAlways : THREE.BoneIndexWeightsTextureNever;
			
						object.material.needsUpdate = true;

					} );

				}

			}


			function showModel( visibility ) {

				for ( const model of models ) {

					model.visible = visibility;

				}

			}


			function showSkeleton( visibility ) {

				for ( const skeleton of skeletons ) {

					skeleton.visible = visibility;

				}

			}


			function modifyTimeScale( speed ) {

				for ( const mixer of mixers ) {

					mixer.timeScale = speed;

				}

			}


			function deactivateAllActions() {

				actions.forEach( function ( action ) {

					action.stop();

				} );

			}

			function activateAllActions() {

				setWeight( idleActions, settings[ 'modify idle weight' ] );
				setWeight( walkActions, settings[ 'modify walk weight' ] );
				setWeight( runActions, settings[ 'modify run weight' ] );

				actions.forEach( function ( action ) {

					action.play();

				} );

			}

			function pauseContinue() {

				if ( singleStepMode ) {

					singleStepMode = false;
					unPauseAllActions();

				} else {

					if ( idleActions[ 0 ].paused ) {

						unPauseAllActions();

					} else {

						pauseAllActions();

					}

				}

			}

			function pauseAllActions() {

				actions.forEach( function ( action ) {

					action.paused = true;

				} );

			}

			function unPauseAllActions() {

				actions.forEach( function ( action ) {

					action.paused = false;

				} );

			}

			function toSingleStepMode() {

				unPauseAllActions();

				singleStepMode = true;
				sizeOfNextStep = settings[ 'modify step size' ];

			}

			function prepareCrossFade( startActions, endActions, defaultDuration ) {

				// Switch default / custom crossfade duration (according to the user's choice)

				const duration = setCrossFadeDuration( defaultDuration );

				// Make sure that we don't go on in singleStepMode, and that all actions are unpaused

				singleStepMode = false;
				unPauseAllActions();

				// If the current action is 'idle' (duration 4 sec), execute the crossfade immediately;
				// else wait until the current action has finished its current loop

				if ( startActions[ 0 ].clip === idleActions[ 0 ].clip ) {

					executeCrossFade( startActions, endActions, duration );

				} else {

					synchronizeCrossFade( startActions, endActions, duration );

				}

			}

			function setCrossFadeDuration( defaultDuration ) {

				// Switch default crossfade duration <-> custom crossfade duration

				if ( settings[ 'use default duration' ] ) {

					return defaultDuration;

				} else {

					return settings[ 'set custom duration' ];

				}

			}

			function synchronizeCrossFade( startActions, endActions, duration ) {

				for ( const mixer of mixers ) {

					mixer.addEventListener( 'loop', onLoopFinished );
			
					function onLoopFinished( event ) {

						if ( event.action.clip === startActions[ 0 ].clip ) {

							mixer.removeEventListener( 'loop', onLoopFinished );

							executeCrossFade( startActions, endActions, duration );
			
						}
			
					}

				}

			}

			function executeCrossFade( startActions, endActions, duration ) {

				// Not only the start action, but also the end action must get a weight of 1 before fading
				// (concerning the start action this is already guaranteed in this place)

				setWeight( endActions, 1 );

				for ( const endAction of endActions ) {
			
					endAction.time = 0;

				}

				// Crossfade with warping - you can also try without warping by setting the third parameter to false

				for ( let i = 0; i < endActions.length; ++ i ) {

					startActions[ i ].crossFadeTo( endActions[ i ], duration, true );

				}

			}

			// This function is needed, since animationAction.crossFadeTo() disables its start action and sets
			// the start action's timeScale to ((start animation's duration) / (end animation's duration))

			function setWeight( actions, weight ) {

				for ( const action of actions ) {

					action.enabled = true;
					action.setEffectiveTimeScale( 1 );
					action.setEffectiveWeight( weight );
			
	}

			}

			// Called by the render loop

			function updateWeightSliders() {

				settings[ 'modify idle weight' ] = idleWeight;
				settings[ 'modify walk weight' ] = walkWeight;
				settings[ 'modify run weight' ] = runWeight;

			}

			// Called by the render loop

			function updateCrossFadeControls() {

				if ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {

					crossFadeControls[ 0 ].disable();
					crossFadeControls[ 1 ].enable();
					crossFadeControls[ 2 ].disable();
					crossFadeControls[ 3 ].disable();

				}

				if ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {

					crossFadeControls[ 0 ].enable();
					crossFadeControls[ 1 ].disable();
					crossFadeControls[ 2 ].enable();
					crossFadeControls[ 3 ].disable();

				}

				if ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {

					crossFadeControls[ 0 ].disable();
					crossFadeControls[ 1 ].disable();
					crossFadeControls[ 2 ].disable();
					crossFadeControls[ 3 ].enable();

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				// Render loop

				requestAnimationFrame( animate );

				idleWeight = idleActions[ 0 ].getEffectiveWeight();
				walkWeight = walkActions[ 0 ].getEffectiveWeight();
				runWeight = runActions[ 0 ].getEffectiveWeight();

				// Update the panel values if weights are modified from "outside" (by crossfadings)

				updateWeightSliders();

				// Enable/disable crossfade controls according to current weight values

				updateCrossFadeControls();

				// Get the time elapsed since the last frame, used for mixer update (if not in single step mode)

				let mixerUpdateDelta = clock.getDelta();

				// If in single step mode, make one step and then do nothing (until the user clicks again)

				if ( singleStepMode ) {

					mixerUpdateDelta = sizeOfNextStep;
					sizeOfNextStep = 0;

				}

				// Update the animation mixer, the stats panel, and render this frame

				for ( const mixer of mixers ) {
			
					mixer.update( mixerUpdateDelta );

				}

				stats.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
